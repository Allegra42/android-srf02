/*
 * Copyright (C) 2015 Anna-Lena Marx
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include <fcntl.h>
#include <errno.h>
#include <math.h>
#include <poll.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/select.h>
#include <stdio.h>
#include <stdlib.h>

#include <cutils/log.h>

#include "proximity_sensor.h"


/*
* Constructor for Proximity Sensor HAL driver. Calling Constructor of super class SensorBase to get an InputEventReader
* for reading values from input event subsystem in the kernel driver. 
*/
ProximitySensor::ProximitySensor ()
	: SensorBase (NULL, "SRF02 input event module"), //second param for getting input events from kernel driver
	  	mEnabled (0),
	  	mInputReader((size_t)(4)),
	  	mHasPendingEvent(true)
	 {

	// mPendingEvent -> sensors_event_t -> struct for store data about the sensor
	// sensor value is stored in mPendingEvent.distance

	mPendingEvent.sensor = ID_PX;
	mPendingEvent.type = SENSOR_TYPE_PROXIMITY;
	mPendingEvent.distance = 5;
	memset(mPendingEvent.data, 0, sizeof(mPendingEvent.data));

	// Enabling driver in kernel
	enable(0, 1);
}

/*
* Destructor for Proximity Sensor HAL. Disabling kernel driver
*/
ProximitySensor::~ProximitySensor () {
	enable(0, 0);
}

/*
* Set initial State.
*/
int ProximitySensor::setInitialState () {
	mHasPendingEvent = true;
	mPendingEvent.distance = 5; // as a start value

	return 0;
}

/*
* Enabling or disabling kernel driver for Proximity Sensor.
*/
int ProximitySensor::enable (int32_t handle, int en) {
	 int newState = en ? 1 : 0;
	 int err = 0;

	 if (newState != mEnabled) {
		 if (!mEnabled && dev_name != NULL) {
			 open_device();
		 }

		 char sysfs [PATH_MAX];

		 strcpy (sysfs, I2C);
		 strcat (sysfs, "value_now");

		 ALOGI_IF (DEBUG, "proximitysensor enable.open(%s), en (%d)", sysfs, en);

		 int fd = open (sysfs, O_RDWR);

		 if (fd < 0) {
			 ALOGE ("proximitysensor couldn't open '%s' input device", sysfs);
			 err = -1;
		 }
		 else {
			 //sensor enabling in sysfs
			 char buf [2];

			 buf [0] = newState ? '1' : '0';
			 buf [1] = '\0';

			 write (fd, buf, sizeof(buf));
			 close (fd);
			 setInitialState();

			// ALOGE("srf02 - enable sensor in sysfs \n ");
		 }
	 }
	 mEnabled = newState;
	 mHasPendingEvent = true;

	 if (!mEnabled && dev_name != NULL) {
		 close_device();
	 }
	 return err;
}

/*
* Return mHasPendingEvent.
*/
bool ProximitySensor::hasPendingEvents () const {
	return mHasPendingEvent;
}

/*
* Reading sensor events generated by input event subsystem in kernel driver.
*/
int ProximitySensor::readEvents (sensors_event_t* data, int count) {
	if (count < 1) {
		return -EINVAL;
	}
	if (mHasPendingEvent) {
		mHasPendingEvent = false;
		mPendingEvent.timestamp = getTimestamp();
		*data = mPendingEvent;
		return mEnabled ? 1 : 0;
	}

	// data_fd technically set in super class constructor but value got overwritten
	// so data_fd is set new
	data_fd = openInput("SRF02 input event module");

	ssize_t n = mInputReader.fill(data_fd);
	if (n < 0) {
		return n;
	}

	int numEventRecieved = 0;
	input_event const* event;

	while (count && mInputReader.readEvent(&event)) {
		// evaluating event type set in kernel driver
		int type = event->type;
		// ALOGD("sensor in ProximitySensor readEvents() - event->type is: %d", type);
		if (type == EV_ABS) {
			if (event->code == ABS_DISTANCE) {
				// ALOGD("sensor in ProximitySensor readEvents() in if event->code == ABS_DISTANCE -> input event kernel");
				mPendingEvent.sensor = ID_PX;
				mPendingEvent.type = SENSOR_TYPE_PROXIMITY;
				mPendingEvent.distance = (float) event->value;
				// ALOGD("sensor srf02 - value is : %d	\n ", event->value);
			}
		}
		else if (type == EV_SYN) {
			// ALOGD("sensor in ProximitySensor readEvents() in if type == EV_SYN");
			mPendingEvent.timestamp = timevalToNano(event->time);

			if (mEnabled) {
				*data++ = mPendingEvent;
				count--;
				numEventRecieved++;
			}
		}
		else {
			ALOGE ("ProximitySensor: unknown event (type=%d, code=%d)", type, event->code);
		}
		mInputReader.next();
		mHasPendingEvent=true;
	}
	return numEventRecieved;
}

float ProximitySensor::indexToValue(size_t index) const {
	return index;
}

int ProximitySensor::getEnable(int handle) {
	return mEnabled;
}

int ProximitySensor::setEnable(int handle, int enabled) {
	//mEnabled = enabled;
	// ALOGE ("ProximitySensor: enable is: %d", enabled);
	enable (handle, enabled);
	return enabled;
}


